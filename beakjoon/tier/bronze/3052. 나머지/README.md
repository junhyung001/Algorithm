# 나머지

### 문제
두 자연수 A와 B가 있을 때, A%B는 A를 B로 나눈 나머지 이다. 예를 들어, 7, 14, 27, 38을 3으로 나눈 나머지는 1, 2, 0, 2이다. 
수 10개를 입력받은 뒤, 이를 42로 나눈 나머지를 구한다. 그 다음 서로 다른 값이 몇 개 있는지 출력하는 프로그램을 작성하시오.

### 입력
첫째 줄부터 열번째 줄 까지 숫자가 한 줄에 하나씩 주어진다. 이 숫자는 1,000보다 작거나 같고, 음이 아닌 정수이다.

### 출력
첫째 줄에, 42로 나누었을 때, 서로 다른 나머지가 몇 개 있는지 출력한다.

### 풀이 핵심 아이디어
[첫번째 시도]
해당 문제를 풀이하는것은 매우 간단한 방법이였다, 먼저 10개의 수를 입력받는다는 제한된 범위가 주어지기 때문에 10개의 숫자를 입력받고 입력받은 수를 42로 나누어 나머지저장 변수에 저장해둔 후 브루트포스 알고리즘 방식으로 모든 경우의 수를 탐색하여 나머지가 동일하지 않다면 결과를 증가시키는 방법을 선택했다.

[두번째 시도(최적화)]
중첩 for를 사용할떄에 상수를 반복하면 O(1)로 매우 작은 연산을 한다고 생각했다, 하지만 개쩌는 코드를 작성하고 싶었다, 좀 더 지리는 방법을 찾던 중 42로 나눈 수는 무조건 42보다 나머지가 작다는 사실을 깨달았다, 그 후 생각을 해보니, 42까지의 bool 변수를 만들어 flase로 초기화 한 후 나머지가 나온 경우만 true로 바꿔주고 cnt를 증가하면 된다는것을 깨달았다, 그 후 바로 구현을 했다, 성공했다.

### 1. 요구사항
10개의 숫자를 입력받고, 각 숫자를 42로 나눈 나머지를 구한 뒤 서로 다른 나머지의 개수를 출력한다.

### 2. 구현을 위해 필요한 정보
- 입력 정보 : 10개의 정수. 각 정수는 0 이상, 1000 이하.
- 출력 정보 : 첫째 줄에, 42로 나누었을 때, 서로 다른 나머지가 몇 개 있는지 출력한다.

### 3. 접근 아이디어
- 나머지 변수 : 입력값을 42로 나눈 나머지를 구한다.
- 중복 제거: 42로 나눈 나머지는 0~41 사이의 값이므로, 길이가 42인 bool 배열(check)을 만들어 해당 나머지 값이 이미 등장했는지 기록한다.
- 카운트 방식
    - 배열에서 해당 나머지의 값이 false이면 아직 등장하지 않은 것이므로 true로 변경하고 카운트(result++)를 증가시킨다.
    - 이미 등장한 나머지는 무시함.
### 4. 구현 과정
1. 배열 초기화: bool check[42] = {false};로 모든 나머지 등장 여부를 초기화.
2. 입력 반복: for문(10회)을 사용하여 정수를 입력받는다.
3. 나머지 계산: 입력받은 정수를 42로 나눈 나머지를 mod에 저장한다.
4. 중복 체크
- check[mod]가 false이면 → check[mod] = true, result++.
- check[mod]가 true이면 → 이미 등장했으므로 넘어간다.
5. 출력: 반복이 끝나면 cout << result;로 서로 다른 나머지 개수를 출력.


### 5. 체크 사항
- 나머지는 항상 0~41 범위이므로 배열 범위를 벗어나지 않는다.
- 입력 값은 음수가 아니고 1000 이하이므로 추가 검증이 필요 없다.
- 10개의 입력 모두 동일한 값이라면 결과는 1이어야 한다.
- 10개의 입력이 모두 다른 나머지를 가질 경우 결과는 최대 10이 된다.


### 6. 최적화
깔끔~하게 최적화 했습니다.

### 7. 시간복잡도
시간 복잡도
입력 반복은 10회(O(10) → 상수 시간), 나머지 계산과 배열 체크는 O(1).
입력이 제한되어 있기때문에 아주 작은 시간복잡도를 확인 할 수 있다.
