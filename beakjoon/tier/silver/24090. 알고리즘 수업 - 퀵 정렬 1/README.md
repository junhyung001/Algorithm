# 제목
알고리즘 수업 - 퀵 정렬 1
  

### 문제
오늘도 서준이는 퀵 정렬 수업 조교를 하고 있다. 아빠가 수업한 내용을 학생들이 잘 이해했는지 문제를 통해서 확인해보자.

N개의 서로 다른 양의 정수가 저장된 배열 A가 있다. 퀵 정렬로 배열 A를 오름차순 정렬할 경우 배열 A에 K 번째 교환되는 수를 구해서 우리 서준이를 도와주자.

크기가 N인 배열에 대한 퀵 정렬 의사 코드는 다음과 같다.
~~~
quick_sort(A[p..r]) { # A[p..r]을 오름차순 정렬한다.
    if (p < r) then {
        q <- partition(A, p, r);  # 분할
        quick_sort(A, p, q - 1);  # 왼쪽 부분 배열 정렬
        quick_sort(A, q + 1, r);  # 오른쪽 부분 배열 정렬
    }
}

partition(A[], p, r) {
    x <- A[r];    # 기준원소
    i <- p - 1;   # i는 x보다 작거나 작은 원소들의 끝지점
    for j <- p to r - 1  # j는 아직 정해지지 않은 원소들의 시작 지점
        if (A[j] ≤ x) then A[++i] <-> A[j]; # i값 증가 후 A[i] <-> A[j] 교환
    if (i + 1 != r) then A[i + 1] <-> A[r]; # i + 1과 r이 서로 다르면 A[i + 1]과 A[r]을 교환
    return i + 1;
}
~~~
### 입력
첫째 줄에 배열 A의 크기 N(5 ≤ N ≤ 10,000), 교환 횟수 K(1 ≤ K ≤ 108)가 주어진다.

다음 줄에 서로 다른 배열 A의 원소 A1, A2, ..., AN이 주어진다. (1 ≤ Ai ≤ 109)

### 출력
K 번째 교환되는 두 개의 수를 작은 수부터 한 줄에 출력한다. 교환 횟수가 K 보다 작으면 -1을 출력한다.


## 풀이 핵심 아이디어
문제에서 주어진 의사코드대로 퀵정렬을 구현한 후 swap이 발생하는 경우를 카운트하는 변수를 만들어 횟수를 체킹하고 K번째 교환된 수를 출력한다, 교환횟수가 K보다 작은 경우엔 -1를 출력한다.
  

### 1. 요구사항
- K번째 교환되는 두 수를 출력한다.
- 출력 : 교환된 두 수

### 2. 구현을 위해 필요한 정보
- 배열 A의 크기 N(5 ≤ N ≤ 10,000)
- 교환 횟수 K(1 ≤ K ≤ 108)
- 교환 횟수가 K 보다 작은 경우 -1 출력
  

### 3. 접근 아이디어
- 퀵 정렬을 구현한다.
→ quick_sort 함수를 구현한다, 해당 함수는 재귀를 담당하는 부분으로 구현
→ partition_custom 함수를 구현한다, 기준 원소와, 원소의 끝자리를 선언한 후 조건에 부합할 경우 swap을 진행하고 cnt를 증가한다.
  

### 4. 구현 과정
1. 입력 받기
    - 배열 크기 N, 교환 횟수 K, 그리고 배열 A의 원소들을 입력받는다.
2. 교환 카운트 변수 선언
    - swap이 발생할 때마다 cnt를 1씩 증가시킨다. cnt가 K가 되면 현재 교환된 두 값을 출력하고 프로그램을 종료한다.
3. partition_custom 함수 구현
    -  기준 원소를 배열의 가장 마지막 값으로 선택한다.
    - 왼쪽부터 기준 원소와 대소 비교하여 조건에 맞으면 바로 swap 수행, swap할 때마다 cnt 증가.
    - 모든 비교가 끝난 뒤 원소의 올바른 위치로 이동(필요시 swap).

### 5. 체크 사항

- swap 횟수 세기
    - partition 알고리즘 내에서 swap이 발생할 때마다 꼭 cnt를 1 증가시켜야 한다. 조건문 위치를 놓치면 결과가 달라질 수 있다.

- K번째 교환에 즉시 출력
    - cnt==K일 때, 곧바로 교환된 두 원소를 출력하고 프로그램을 종료하는 것이 중요하다. 출력 후 exit(0)을 사용하여, 이후 불필요한 연산을 방지한다.
  

### 6. 최적화
- 좀 더 생각이 필요.

## 시간복잡도

- 퀵정렬의 평균적인 분할 횟수 → log N
각 분할마다 N번의 비교와 최대 N번의 교환
- 최악 시간복잡도: O(N²)
→ 피벗이 항상 최소값 또는 최대값으로 선택되는 경우
예: 이미 정렬된 배열에서 마지막 원소를 피벗으로 선택