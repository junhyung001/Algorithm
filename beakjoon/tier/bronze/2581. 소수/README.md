# 제목
소수
  

### 문제
자연수 M과 N이 주어질 때 M이상 N이하의 자연수 중 소수인 것을 모두 골라 이들 소수의 합과 최솟값을 찾는 프로그램을 작성하시오.
예를 들어 M=60, N=100인 경우 60이상 100이하의 자연수 중 소수는 61, 67, 71, 73, 79, 83, 89, 97 총 8개가 있으므로, 이들 소수의 합은 620이고, 최솟값은 61이 된다.

### 입력
입력의 첫째 줄에 M이, 둘째 줄에 N이 주어진다.
M과 N은 10,000이하의 자연수이며, M은 N보다 작거나 같다.

### 출력
M이상 N이하의 자연수 중 소수인 것을 모두 찾아 첫째 줄에 그 합을, 둘째 줄에 그 중 최솟값을 출력한다.
단, M이상 N이하의 자연수 중 소수가 없을 경우는 첫째 줄에 -1을 출력한다.

## 풀이 핵심 아이디어
[첫번째 시도]
이 문제는 두 정수 M과 N을 입력받아, M 이상 N 이하 범위에 있는 소수들의 총합과 그 중 가장 작은 소수를 구하는 문제이다.
먼저 M부터 N까지 반복하는 바깥 루프를 하나 구성하고, 각 숫자 i에 대해 소수 여부를 판별하기 위해 2부터 N까지의 값을 갖는 j를 사용하는 내부 루프를 구성하였다.
내부 루프에서 i % j == 0이면 i가 j로 나누어 떨어진다는 뜻이므로 소수가 아니므로 바로 break하여 다음 숫자로 넘어가게 하였다.
그리고 만약 j가 i-1까지 도달하였다면, 즉 i보다 작은 모든 수로 나누어 떨어지지 않았다는 뜻이므로 i는 소수이다.
이 경우 sum에 i를 더하고, min이 아직 초기값(0)일 때만 최소값으로 설정하였다.
(이 방식은 작은 수부터 차례대로 탐색하기 때문에 가장 먼저 발견된 소수가 자동으로 최소 소수가 된다.)
또한, i == 2일 때를 따로 처리해주었는데, 이는 2가 소수임에도 불구하고 내부 루프의 조건이 j <= n으로 되어 있어 정상적으로 소수로 인식되지 않을 수 있는 예외 상황을 보완하기 위함이다.
마지막으로, 최소 소수가 존재하면 sum과 min을 출력하고, 없으면 -1을 출력하도록 하였다.

[두번째 시도]
소수 문제를 다시 한번 에라토스테네스의 체 방식으로 접근해보았다, 해당 방법은 2부터 입력받은 N까지의 모든 수를 bool형 변수에 true형태로 저장한 후 소수가 아닌 경우의 수를 false로 설정하여 에라토스테네스의 체를 구현한다, 그 후 문제에서 의도한 최솟값과 합계를 구한다, 처음 접근에 비해 에라토스테네스의 체를 활용해 구현하니 더욱더 간결하고 성능이 좋은 코드가 완성되었다, 해당 이유로는 에라토스테네스의 체를 활용한 풀이는 시간복잡도가 O(n log log n)이 된다, 하지만 내가 처음 시도한 방법은 O(N^2)으로 매우 비효율적인 방법이라는 것을 인지한 후 코드를 수정하였다.

### 1. 요구사항
- 제한 범위 내에 있는 소수를 구한다.
- 제한 범위 내에 있는 소수들의 합계를 구한다.
- 제한 범위 내에 있는 소수들 중 최솟값을 구한다.

### 2. 구현을 위해 필요한 정보
- M과 N은 10,000이하의 자연수이며, M은 N보다 작거나 같다.

### 3. 접근 아이디어
- 소수의 합과 최솟값을 구하는 문제지만 사실 소수를 판별해 내는 과정이 가장 중요하다 생각했다, 고로 인해 소수를 판별하는 방법을 에라토스테네스의 체 알고리즘을 사용하여 구현하기로 했다.
  

### 4. 구현 과정
1. 입력 받기
    - 제한 범위 안의 M과 N을 입력받는다.
2. primenumber()함수에 인수를 전달하여 호출한다.
    - 제한 범위 M과 N을 전달한다.
3. primenumber() 함수 구현
    - 2부터 N까지 정해져있는 범위 내에 모든 번지수에 true를 넣는다.
    - 2부터 n까지 반복하며, isPrime이 true일 경우 내부 for문을 이용해 합성수를 제거한다.
    - 모든 합성수를 제거하였다면 제한된 범위 내의 m과 n사이의 isPrime이 true인 경우의 수를 합해주고, 최소값을 구해준다.
4. 최종 출력
    - 최소값이 존재하면 합과 최소값을 출력한다.
    - 최소값이 존재하지 않는다면 -1을 출력후 종료한다.
### 5. 체크 사항
- 경계값 처리
- 1은 소수가 아님: isPrime[1] = false
- 2는 가장 작은 소수: 올바르게 처리되는지 확인
- M=N인 경우 처리
- 소수가 없을 때 -1 출력

### 6. 최적화
- 첫 번째 시도는 단순히 하나하나 나눠보면서 소수인지 확인하는 방식을 선택하여 O(N^2)의 시간복잡도를 가졌다, 하지만 두번째 시도는 에라토스테네스의 체 알고리즘을 사용해 O(n log log n)의 시간복잡도를 가진다, 고로 더이상의 최적화는 필요하지 않다고 판단하였다.

## 7. 시간복잡도
- 에라토스테네스의 체: O(N log log N)
- 범위 내 소수 탐색: O(N-M+1)
- 전체: O(N log log N)