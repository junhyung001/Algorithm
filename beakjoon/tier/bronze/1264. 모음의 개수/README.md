# 제목
모음의 개수
  
### 문제
영문 문장을 입력받아 모음의 개수를 세는 프로그램을 작성하시오. 모음은 'a', 'e', 'i', 'o', 'u'이며 대문자 또는 소문자이다.

### 입력
입력은 여러 개의 테스트 케이스로 이루어져 있으며, 각 줄마다 영어 대소문자, ',', '.', '!', '?', 공백으로 이루어진 문장이 주어진다. 각 줄은 최대 255글자로 이루어져 있다. 입력의 끝에는 한 줄에 '#' 한 글자만이 주어진다.

### 출력
각 줄마다 모음의 개수를 세서 출력한다.

## 풀이 핵심 아이디어
해당 문제는 모음의 갯수를 세면되는 아주 간단한 문제였다, 두가지 아이디어가 있었다, cpp을 활용해 getline()을 활용한 방법과 c언어를 활용해 scanf()의 scanf("%[^\n]")을 통해 개행문자가 올때까지 입력받는 방법을 선택해서 두가지 방법으로 문제를 구현했다, 그 후 모음을 비교하는 방법은 함수를 만들어 대문자와 소문자 모음의 갯수는 총 10개이기떄문에 문자열만큼 반복하면서 모음에 해당하는 경우엔 모음을 카운팅하는 변수의 값을 증가시키는 방법을 선택했다.


### 1. 요구사항
1. N, M 크기의 성이 주어지고 그 성 가로열과 세로열 중 한칸에 반드시 경비병이 한명은 존재해야한다.

### 2. 구현을 위해 필요한 정보
1. 입력되는 문자는 최대 255글자이다.
2. 입력의 끝은 #이 입력된다.
3. 대문자와 소문자 모음을 모두 비교해야한다.

### 3. 접근 아이디어
1. 개행문자가 입력될때까지 문자열을 입력받는다.
2. 모음을 체킹한다.
3. 모음의 갯수를 출력한다.

### 4. 구현 과정
입력 처리
1. 반복문 시작: 입력의 끝인 '#'이 들어올 때까지 무한 루프(while (1))를 시작합니다.
2. 문자열 입력: scanf("%[^\n]", str);를 사용하여 개행 문자(\n)가 나타나기 전까지의 모든 문자(공백 포함)를 문자열 배열 str에 입력받습니다.
3. 개행 문자 처리: scanf("%[^\n]", str);는 개행 문자를 입력 버퍼에 남기므로, 다음 입력을 위해 getchar();를 호출하여 이 개행 문자를 소비하고 버퍼를 비웁니다.
4. 종료 조건 확인: strcmp(str, "#") == 0을 통해 입력받은 문자열이 '#'인지 확인합니다. '#'이면 break를 통해 반복문을 종료합니다.

check_include_Vowel 함수
1. 초기화: 모음의 개수를 저장할 변수 cnt를 0으로 초기화합니다.
2. 외부 반복문 (문자열 순회): 입력 문자열 arr의 길이(strlen(arr))만큼 반복하는 외부 루프를 실행합니다. (for (int i = 0; i < strlen(arr); i++))
3. 내부 반복문 (모음 비교): 미리 정의된 모음 배열 Vowel[10] (소문자 5개, 대문자 5개)의 길이인 10만큼 반복하는 내부 루프를 실행합니다. (for (int j = 0; j < 10; j++))
4. 모음 확인: if (arr[i] == Vowel[j])를 사용하여 현재 문자열의 문자(arr[i])가 모음 배열의 문자 중 하나와 일치하는지 비교합니다.
5. 카운트 증가 및 중단: 일치하면 cnt를 1 증가시키고, 해당 문자는 이미 모음으로 확인되었으므로 더 이상 나머지 모음과 비교할 필요 없이 내부 반복문을 중단합니다. (현재 구현에서는 break가 없으나, 성능 최적화를 위해 추가 가능합니다. 현재 코드는 모든 모음을 순회하며 비교합니다.)
6. 결과 반환: 문자열 순회가 끝나면 최종 모음 개수 cnt를 반환합니다.


### 5. 체크 사항
개행 문자: scanf 이후에 getchar()를 사용하여 입력 버퍼에 남아있는 개행 문자를 확실히 소비하여 다음 반복에서 입력을 방해하지 않도록 처리했는지 확인했습니다.

### 6. 최적화
시간복잡도가 O(N)으로 충분하다 판단했습니다.

## 7. 시간복잡도
255의 문자의 입력갯수를 가졌고 2중 반복 루프가 있어도 상수번 만큼 반복하기 떄문에 O(N)의 시간복잡도를 가진다.