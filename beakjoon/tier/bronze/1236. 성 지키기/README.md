# 제목
성 지키기
  
### 문제
영식이는 직사각형 모양의 성을 가지고 있다. 성의 1층은 몇 명의 경비원에 의해서 보호되고 있다. 영식이는 모든 행과 모든 열에 한 명 이상의 경비원이 있으면 좋겠다고 생각했다.
성의 크기와 경비원이 어디있는지 주어졌을 때, 몇 명의 경비원을 최소로 추가해야 영식이를 만족시키는지 구하는 프로그램을 작성하시오.

### 입력
첫째 줄에 성의 세로 크기 N과 가로 크기 M이 주어진다. N과 M은 50보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에는 성의 상태가 주어진다. 성의 상태는 .은 빈칸, X는 경비원이 있는 칸이다.

### 출력
첫째 줄에 추가해야 하는 경비원의 최솟값을 출력한다.

## 풀이 핵심 아이디어
해당 문제 풀이는 정해진 범위가 50 이내의 자연수였기 때문에 나는 브루트포스(Brute Force) 방식으로 모든 입력된 크기의 모든 배열을 탐색하는 방법을 선택했다
접근한 방법은 행과 열을 비교해 행에 경비병이 하나라도 있다면 그 열은 조건에 부합한다 판단한다, 열도 행과 동일하게 모든 열을 비교해 경비병이 하나라도 있다면 그 행은 조건에 부합한다 판단한다, 조건에 부합하지 않는 경우는 행과 열의 경비병을 놓아야하는 갯수를 파악하는 변수를 1증가시켜 행과 열을 카운트 한 값중 작은 값을 출력한다.

### 1. 요구사항
1. N, M 크기의 성이 주어지고 그 성 가로열과 세로열 중 한칸에 반드시 경비병이 한명은 존재해야한다.

### 2. 구현을 위해 필요한 정보
1. 성의 상태는 ,과 X로 주어진다, 이 중 빈 상태는 ',' 경비원이 존재하는 경우는 'X'로 나타낸다.
2. 성의 상태를 보고 추가해야하는 경비원의 최소값을 구한다.

### 3. 접근 아이디어
1. 모든 행과 열을 탐색해 'X'가 아닌경우를 찾는다.
2. 'X'가 아닌경우 경비원이 없는 경우이기 때문에 행과 열의 크기와 같아지면 행과 열의 병비원 추가 카운트값을 1증가한다.
3. 카운트 2개중 작은 카운트를 출력한다.

### 4. 구현 과정
1. 입력
    - N, M 읽기.
    - N×M 배열 입력받기.
2. 행 검사
    - i번째 행에 X가 있는지 확인.
    - 없으면 countR++.
3. 열 검사
    - j번째 열에 X가 있는지 확인.
    - 없으면 countC++.
4. 결과 출력
    - max(countR, countC) 출력.

### 5. 체크 사항
열 검사 시 바깥 루프는 `for (int col=0; col<M; col++)`, 안쪽은 `for (int row=0; row<N; row++)`로 해야 함.

### 6. 최적화
해당 문제는 시간복잡도가 O(N^2)의 시간복잡도를 가지지만 문제에서 50이하의 수만이 제공된다는 제한되는 조건이 있기때문에 최대 7500정도의 연산을 진행하게되기 때문에 최적화는 불필요하다고 판단했다.

## 7. 시간복잡도
- 입력 과정 2중 for문 -> O(N^2)
- Row 검사 2중 for문 -> O(N^2)
- Column 검사 2중 for문 -> O(N^2)
즉 O(N^2)의 시간복잡도를 가진다