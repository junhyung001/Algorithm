# 제목
분해합

### 문제
어떤 자연수 N이 있을 때, 그 자연수 N의 분해합은 N과 N을 이루는 각 자리수의 합을 의미한다. 어떤 자연수 M의 분해합이 N인 경우, M을 N의 생성자라 한다. 예를 들어, 245의 분해합은 256(=245+2+4+5)이 된다. 따라서 245는 256의 생성자가 된다. 물론, 어떤 자연수의 경우에는 생성자가 없을 수도 있다. 반대로, 생성자가 여러 개인 자연수도 있을 수 있다.

### 입력
첫째 줄에 자연수 N(1 ≤ N ≤ 1,000,000)이 주어진다.


### 출력
첫째 줄에 답을 출력한다. 생성자가 없는 경우에는 0을 출력한다.


## 풀이 핵심 아이디어
해당 문제는 분해합에 대한 개념을 먼저 이해하면 문제를 풀이하기 쉬워진다, 먼저 분해합이란 자연수 N의 분해합은 N과 N을 이루는 각 자리수의 합을 의미한다, 쉽게 말해 245라는 숫자가 있을시 245+2+4+5 = 256이 된다, 결국 해당 문제는 브루트 포스 방식으로 접근해야하는 문제였다, 이유로는 방정식을 사용한 접근을 시도했는데, 문제에서 제공하는 범위가 1,000,000이기 때문에 벙정식을 통한 접근에는 어려움이 있다는 점을 깨닫게 되었고 브루트 포스 방식으로 모든 경우를 비교하는 방식을 사용했다, 즉 245라는 숫자를 입력받았다면 1부터 245까지 반복해 245에 도달한 숫자를 100의 자리 10의자리 1의 자리로 나누어 문제를 해결하는 방법을 선택했다.

### 1. 요구사항
N을 입력받고 N의 분해합을 구하시오.

### 2. 구현을 위해 필요한 정보
1. N의 범위
    - N(1 ≤ N ≤ 1,000,000)

### 3. 접근 아이디어
입력받은 수를 방정식으로 해결하려는 시도를 진행했지만 불가능하다는것을 판단하고 반복문을 사용하여 풀이했다, 즉 접근한 아이디어로는 입력받은 수까지를 반복하며 생성자가 있는지 자리수별 계산을 통해 판단하는 과정을 진행하여 문제를 풀이했다.

### 4. 구현 과정
1차 반복문 입력받은 수 N까지 반복하기 위해서 1~N까지 반복한다, N까지 반복하며 자리수별 계산을 하는 2차 반복 루프를 돌린다, 만약 sum의 값이 입력받은 N의 값과 같을 경우 반복문을 종료하며 결과를 출력한다.

### 5. 체크 사항
입력한 계산의 값이 int형이기 때문에 소수점 밑은 버린다는 점을 생각하여 구현해야한다, 0이 되는 시점이 어느시점인지 잘 구분하는것이 중요하다.

### 6. 최적화
해당코드는 해당 문제에서 충분한 시간복잡도를 가지고 있기 때문에 최적화는 불필요하다고 판단했습니다.

### 7. 시간복잡도
해당 코드의 시간복잡도는 O(N log N)입니다.
``` c++
for (int i = 1; i <= n; i++)
```
해당 부분은 N번 반복하기 때문에 O(N)입니다.

``` c++
while (temp > 0) {
    sum += temp % 10;
    temp /= 10;
}
```
해당 코드는 temp가 10으로 나눠지면서 자릿수 만큼 반복합니다, 즉 log N이라 할 수 있습니다.
따라서 O(N log N)의 시간복잡도를 가집니다.