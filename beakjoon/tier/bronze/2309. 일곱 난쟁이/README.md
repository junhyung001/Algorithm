# 제목
일곱 난쟁이

### 문제
왕비를 피해 일곱 난쟁이들과 함께 평화롭게 생활하고 있던 백설공주에게 위기가 찾아왔다. 일과를 마치고 돌아온 난쟁이가 일곱 명이 아닌 아홉 명이었던 것이다.
아홉 명의 난쟁이는 모두 자신이 "백설 공주와 일곱 난쟁이"의 주인공이라고 주장했다. 뛰어난 수학적 직관력을 가지고 있던 백설공주는, 다행스럽게도 일곱 난쟁이의 키의 합이 100이 됨을 기억해 냈다.
아홉 난쟁이의 키가 주어졌을 때, 백설공주를 도와 일곱 난쟁이를 찾는 프로그램을 작성하시오.

### 입력
아홉 개의 줄에 걸쳐 난쟁이들의 키가 주어진다. 주어지는 키는 100을 넘지 않는 자연수이며, 아홉 난쟁이의 키는 모두 다르며, 가능한 정답이 여러 가지인 경우에는 아무거나 출력한다.

### 출력
일곱 난쟁이의 키를 오름차순으로 출력한다. 일곱 난쟁이를 찾을 수 없는 경우는 없다.


## 풀이 핵심 아이디어

### 1. 요구사항
1. 아홉명의 난쟁이 중 7명의 난쟁이를 찾아라.
    - 7명의 난쟁이가 되는 조건은 키의 합계가 100이 되는 경우의 수이다.

### 2. 구현을 위해 필요한 정보
- 주어지는 난쟁이의 키는 100을 넘지 않는 자연수이며 아홉 난쟁이의 키는 모두 다르다.
- 정답이 여러가지인 경우에는 아무거나 출력해도 무방하다.


### 3. 접근 아이디어
1. 문제를 처음 접근할때 첫번째로 해야할것은 오름차순으로 정렬하는것.
2. 일곱 난쟁이의 합이 100이 된다는점을 구현해야된다는점 -> 해당 경우는 전체 합계에서 두 수를 뺏을때 100인경우를 고려하면 유리할것으로 판단
3. 예상과 동일하게 문제를 해결했다, 즉 문제를 접근하는 방법은 간단하게 생각을했다, 먼저 주어진 9개의 수를 입력받고, 해당 수들의 합을 구한다, 9개의 주어진 수를 오름차순으로 정렬한 후 합계가 100인 경우를 구하면 된다, 여기서 합계가 100인 경우를 구하는 경우를 해결하는 방법으로 입력받은 9개의 수에서 n번째와 n+1번째 수를 뺏을시 100이 되는 경우로 접근하여 문제를 해결하는 방법을 선택해 문제를 해결 할 수 있었다.


### 4. 구현 과정
해당 문제를 풀이할때 필수적 구현이 필요한것은 딱 2가지였다, 1번 오름차순 정렬, 2번 100이되는 경우 찾기
1. 오름차순정렬
    - 가장 작은수부터 정렬하는 방법을 선택하여 오름차순 정렬을 구현하였습니다.
2. 키의 합계가 100이 되는 경우 찾기
    - 입력받은 아홉 난쟁이의 모든 키를 구한다, 그 후 2명의 키를 제외한 7명의 키의 합계가 100이 되는 경우를 구하여 출력한다.

### 5. 체크 사항
주어진 모든 범위를 체크하여 난쟁이의 키가 100인지 여부를 확인한다.


### 6. 최적화
저는 여기까지,,, 좀 더 성장해서 해보는걸ㄹ,,,,


### 7. 시간복잡도
```
void sort(int arr[], int size){
    int temp, min, index;
    for (int i = 0; i < size; i++) {
        min = 9999;
        index = i;
        for (int j = i; j < size; j++) {
            if (min > arr[j]) {
                min = arr[j];
                index = j;
            }
        }
        temp = arr[i];
        arr[i] = arr[index];
        arr[index] = temp;
    }
}
```
해당 코드는 선택 정렬로 코드를 구현한것이므로 O(N²)의 시간복잡도를 가집니다.

```
void find(int arr[], int size, int sum){
    for (int i = 0; i < size-1; i++) {
        for (int j = 1; j < size; j++) {
            if (sum - arr[i] - arr[j] == 100) {
                for (int k = 0; k < size; k++) {
                    if (k != i && k != j) {
                        cout << arr[k] << endl;
                    }
                }
                return;
            }
        }
    }
}
```
해당 코드는 바깥 for문의 경우 N번 안쪽 for문의 경우 N번의 시간복잡도를 가지며 안쪽의 k루프는 상수번의 시간복잡도를 가지기 때문에 무시한다,
따라서 해당 코드는 O(N²)의 시간 복잡도를 가진다.
즉 최종적으로 해당 코드는 O(N²)의 시간복잡도를 가지는 코드입니다.